% !TEX root = ../Projektdokumentation.tex
\section{Implementierungsphase} 
\label{sec:Implementierungsphase}

\subsection{Iterationsplanung}
\label{sec:Iterationsplanung}
Bevor mit der eigentlichen Implementierung begonnen wurde, wurde zuerst ein Iterationsplan erstellt. In ihm wurden die Iterationsschritte und deren Reihenfolge definiert. Innerhalb einer Iteration wird die zuvor definierte Funktionalität eingebaut. Der erstellte Iterationsplan befindet sich im \Anhang{app:Iterationsplan}.

\subsection{Implementierung der Datenstruktur ECC}
\label{sec:Implementierung der Datenstruktur ECC}
Zuerst wurden alle Dictionary-Objekte, welche im \ac{ECC} gebraucht werden, erstellt. Eine vollständige Liste aller Tabellentypen, Strukturen, Datenelemente und Domänen können dem Anhang entnommen werden. Außerdem wurden die Datenbanktabellen wie in Kapitel~\ref{sec:Datenmodell}: ~\nameref{sec:Datenmodell} beschrieben implementiert. Die AUFK wurde mittels eines Custom Include um das Feld \textsc{zz\_order\_comment} erweitert.

\subsection{Implementierung der Benutzeroberfläche ECC}
\label{sec:Implementierung der Benutzeroberfläche ECC}
In der \ac{GUI} Funktionsgruppe wurde jeweils ein Screen für das Maintenance Programm (Screen 0100) und ein Screen für das Administration Programm (Screen 0500) mithilfe des Screen Painters angelegt und gestaltet. Der Screen 0100 enthält lediglich einen Custom Container, in welchem dann später das \ac{ALV} angezeigt wird. Der Screen 0500 hat zum jetzigen Zeitpunkt nur ein Label und ein Eingabefeld, dessen Element sich in der Member Struktur des Screens der \ac{GUI} Klasse befindet. Das \ac{PBO} und das \ac{PAI} der Funktionsgruppe wurde dynamisch programmiert. Das bedeutet, dass je nach Screen die zugehörige Methode in der \ac{GUI} Klasse aufgerufen wird. Die User Befehle (OK-Code) werden in ein Member Feld der \ac{GUI} Klasse geschrieben. Außerdem wurde für das Maintenance Programm ein extra Selektionsbildschirm angelegt, in welchem man gewisse Parameter wie Auftragsnummer, Material, Startdatum, Enddatum und Benutzer eingeben kann und somit die dargestellten Aufträge gefiltert werden können. Screenshots der Anwendung befinden sich unter \Anhang{Screenshots}.

\subsection{Implementierung PBO und PAI}
\label{sec:Implementierung PBO und PAI}
Jeder Screen der Funktionsgruppe hat seine eigene \ac{PBO} und \ac{PAI} Methode in der GUI Klasse. Im PBO werden die Daten geladen, bevor sie dann auf dem Screen angezeigt werden. Dies passiert, indem die jeweilige Controller Methode aufgerufen wird. Die Daten werden allerdings nicht jedes Mal neu geladen, wenn das \ac{PBO} aufgerufen wird, sondern nur, wenn die ALV Struktur, welche in der Member Struktur des jeweiligen Screens liegt, initial also ``leer`` ist. Dadurch wird verhindert, dass zu viele Datenbankzugriffe erfolgen, da jedes Mal die Daten neu geladen werden würden. Nichtsdestotrotz kann ein Refresh eingeleiten werden, indem einfach die \ac{ALV} Struktur geleert wird. Im \ac{PAI} werden alle User Befehle (OK-Code) abgefangen, welche vom Screen geworfen werden und dann die jeweilige Aktion ausgeführt. Der OK-Code des jeweiligen Buttons wird im Screen-Painter bzw. im Status des jeweiligen Screens definiert.

\subsection{Implementierung der Geschäftslogik ECC}
\label{sec:Implementierung der Geschäftslogik ECC}
Die eigentliche Geschäftslogik und die Datenbankzugriffe finden alle im Controller statt. Hier wurden mehrere Methoden implementiert, welche die gesamten Aufträge, die derzeit unterstützt werden, (Prozessaufträge, Produktionsaufträge aus der AUFK mit join auf die AFKO für Material Infos und Planaufträge aus der PLAF) laden. Außerdem wurde die Speicherlogik implementiert. In der Member Struktur des Screens gibt es zwei Tabellen, eine für die Daten, die dann tatsächlich im \ac{ALV} angezeigt werden und eine andere, in welcher immer die originalen Daten seit dem letzten Speichern enthalten sind. Beim Speichern werden nun diese zwei Tabellen verglichen und so alle Aufträge, welche sich nicht geändert haben, aussortiert, sodass die Speicherlogik nur auf die tatsächlich modifizierten oder erstellten Aufträge angewendet wird. Diese Aufträge werden dann mithilfe eines RFC ins \ac{APO} System transferiert. (siehe Kapitel~\ref{sec:Implementierung der Geschäftslogik APO}: \nameref{sec:Implementierung der Geschäftslogik APO})     

\subsection{Implementierung der COR Erweiterung}
\label{sec:Implementierung der COR Erweiterung}   
Um die \textsc{cor} Transaktion (1-3) zu erweitern, musste zunächst ein passender Erweiterungspunkt gefunden werden, welcher zum einen, einen Screen Exit und zum anderen, zwei Functions Exits vor und nach dem Laden der Daten hat. Verwendet wurde das Enhancement PPCO0020. Dieses bietet alle Komponenten, die zum Anzeigen der Daten benötigt werden. Zuerst wurde der Screen Exit erstellt und mittels des Screen Painters ein Screen mit einem Label und einem Eingabefeld erstellt und aktiviert. Dann wurde das \ac{PBO} Modul um eine Methode erweitert, sodass das Eingabefeld in der \textsc{COR3} deaktiviert wird, da diese Transaktion nur zum Anzeigen ist. Außerdem wurde in dem Top Include eine globale Struktur vom Typ AUFK angelegt, dessen \textsc{zz\_order\_comment} Feld hinter dem Eingabe Feld liegt. In dem ersten Function Exit, wird diese Struktur dann gefüllt. Da der Planer aber auch die Möglichkeit haben soll, Kommentare von Prozessaufträgen zu ändern bzw. beim Anlegen eines Auftrags anzugeben, wurde noch ein weiterer Funktionsbaustein benötigt, da der oben genannte, keinen Function Exit für das Speichern hat, von wo aus die neu implementierte Speicherlogik aufgerufen werden kann. Hierzu wurde der Erweiterungspunkt PPCO0007 gewählt. Dieser Erweiterungspunkt liefert einen Function Exit, aus welchem dann eine statische Methode aus dem Controller aufgerufen wird, damit der geänderte Kommentar nicht nur in der AUFK, sondern auch in der \textsc{/camelot/oc\_comt} gespeichert wird. Außerdem wird hier auch der \ac{RFC} ausgeführt, damit der Kommentar ins \ac{APO} transferiert wird. Näheres siehe Kapitel~\ref{sec:Implementierung der Geschäftslogik APO}: \nameref{sec:Implementierung der Geschäftslogik APO}.

\subsection{Implementierung der Datenstruktur APO}
\label{sec:Implementierung der Datenstruktur APO} 
Nachdem im \ac{ECC} System nun alles implementiert wurde, musste ein Großteil derselben Datenstrukturen auch im \ac{APO} angelegt werden. Eine Liste aller Dictionary-Objekte kann dem Anhang entnommen werden. Des Weiteren wurde die \textsc{/sapapo/ordflds} Datenbanktabelle um das Feld \textsc{order\_comment} erweitert. Im \ac{APO} wird keine extra Datenbank wie im \ac{ECC} benötigt, da für alle Aufträge die \textsc{/sapapo/ordflds} Tabelle benutzt werden kann.

\subsection{Implementierung der Benutzeroberfläche APO}
\label{sec:Implementierung der Benutzeroberfläche APO} 
Ähnlich wie im \ac{ECC} musste ein Screen(0100) erstellt werden, auf welchem das \ac{ALV} mit den Auftragsdaten und dem Kommentar angezeigt wird. Der zweite Screen, der im \ac{ECC} angelegt wurde, wird im \ac{APO} nicht benötigt, da automatisch alle Kommentaren in der \textsc{/sapapo/ordflds} im Feld \textsc{order\_comment} gespeichert werden. Der Screen 0100 ist genauso aufgebaut wie im \ac{ECC}, nur der Selektionsbildschirm fällt zum jetzigen Zeitpunkt deutlich kleiner aus, da man nur nach Auftragsnummern filtern kann. Screenshots der Anwendung befinden sich unter \Anhang{Screenshots}. 

\subsection{Implementierung der Geschäftslogik APO}
\label{sec:Implementierung der Geschäftslogik APO}  
Wie im \ac{ECC} findet auch im \ac{APO} die gesamte Geschäftlogik im Controller statt. Neben denselben Klassen, die auch im \ac{ECC} vorhanden sind (Constants, Controller, \ac{GUI}, \ac{ALV}), gibt es eine zusätzliche Klasse mit dem Namen \textsc{/camelot/cl\_oc\_rrp}, welche für den \ac{BAdI} und die implizite Erweiterung der RRP3 genutzt wird (Erläuterungen dazu unter Kapitel~\ref{sec:Implementierung der RRP3 Erweiterung}: \nameref{sec:Implementierung der RRP3 Erweiterung}). Außerdem gibt es neben der Funktionsgruppe, welche für das Hauptprogramm genutzt wird, eine weitere Funktionsgruppe \textsc{/camelot/oc\_comment} mit dem Funktionsmodul \textsc{/camelot/oc\_comment\_sync} welche Remote-Enabled ist. Das bedeutet, sie kann aus einem anderen System heraus aufgerufen werden. Diese Methode hat als Importparamter eine Tabelle mit dem Tabellentyp \textsc{/camelot/oc\_ord\_comment\_rfc\_t} (siehe \Anhang{Dictionary-Objekte}). Diese Funktion dient zum Transport der Kommentare vom \ac{ECC} ins \ac{APO}. Die Struktur der Tabelle beinhaltet nur die Auftragsnummer und den Kommentar, um den Traffic möglichst gering zu halten. Die Methode selber sucht mithilfe eines SAP Funktionsbausteins \textsc{/sapapo/dm\_order-\_get\_order} die richtige Auftrags-Id (Orderid) aus dem Livecache zu der gegebenen Auftragsnummer. Mithilfe der Auftrags-Id und dem Kommentar wird dann die \textsc{/sapapo/ordflds} Tabelle aktualisiert.  

\subsection{Implementierung der RRP3 Erweiterung}
\label{sec:Implementierung der RRP3 Erweiterung}   
Um die Produktsicht (RRP3) zu erweitern, wurden nicht wie bei der COR1-3 Customer-Exits, sondern ein \ac{BAdI} und eine implizite Erweiterung verwendet. Der Unterschied zwischen einem Customer-Exit und einem \ac{BAdI} ist, dass der \ac{BAdI} die neuere objektorientierte Variante eines Customer-Exits ist. Statt in Funktionsmodulen Code einzufügen, wird eine vordefinierte Klasse implementiert, deren Methoden wie bei den alten Customer-Exits zu einem bestimmten Zeitpunkt aufgerufen werden. Für diese RRP3 Erweiterung wurde der \ac{BAdI} \textsc{/sapapo/rrp\_io\_col} benötigt. Mit diesem war es möglich an den Feldkatalog, eine interne Tabelle mit Informationen über darzustellende Felder, der rrp3 das Feld \textsc{order\_comment} anzufügen, damit dieses im \ac{ALV} erscheint. Mittels einer zweiten Methode konnten dann die entsprechenden Kommentare in die Tabelle geschrieben werden. Außerdem musste eine implizite Erweiterung angelegt werden, da es mithilfe von Customer-Exits oder \ac{BAdI}s nicht möglich war, die t-style Tabelle der einzelnen Elemente in der \ac{ALV} Tabelle zu ändern, was allerding absolut notwendig ist, um z.B. den Kommentar editierbar zu machen. Die jeweiligen Methoden des \ac{BAdI}s und der impliziten Erweiterung rufen eine statische Methode in der RRP3 Klasse auf, welche genau denselben Namen hat wie die eigentliche Methode des \ac{BAdI}s, um einen besseren Überblick zu verschaffen und sie später gut bei Kunden implementieren zu können. Diese Methoden holen sich dann die Instance des Controllers (Singleton) bzw. eine wird erstellt und rufen dann die jeweiligen Controller Methoden auf.

\Zwischenstand{Implementierungsphase}{Implementierung}
