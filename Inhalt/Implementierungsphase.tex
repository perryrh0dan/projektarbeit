% !TEX root = ../Projektdokumentation.tex
\section{Implementierungsphase} 
\label{sec:Implementierungsphase}

\subsection{Iterationsplanung}
\label{sec:Iterationsplanung}
Bevor mit der eigentlichen Implementierung begonnen wurde, wurde zuerst ein Interationsplan erstellt. In ihm werden die Iterationsschritte und deren Reihenfolge definiert. Innerhalb einer Iteration wird die zuvor definierte Funktionalität eingebaut. Der erstellte Iterationsplan befindet sich im Anhang \Anhang{app:Iterationsplan}.

\subsection{Implementierung der Datenstruktur ECC}
\label{sec:Implementierung der Datenstruktur ECC}
Zuerst wurden alle Dictionary-Objekte, welche im \ac{ECC} gebraucht werden, erstellt. Eine Vollständige Liste aller Tabellen Typen, Strukturen (einer Art mehrdimensionaler Array), Datenelemente und Domänen können dem Anhang entnommen werden. Außerdem wurden die Datenbank Tabellen wie in Kapitel~\ref{sec:Datenmodell}: ~\nameref{sec:Datenmodell} beschrieben implementiert. Die AUFK wurde mittels einem Custom Include um das Feld ZZ\_ORDER\_COMMENT erweitert.

\subsection{Implementierung der Benutzeroberfläche ECC}
\label{sec:Implementierung der Benutzeroberfläche ECC}
In der \ac{GUI} Funktionsgruppe wurden jeweils ein Screen für das Maintenance Programm (Screen 0100) und ein Screen für das Administration Programm (Screen 0500) mithilfe des Screen Panters angelegt und gestaltet. Der Screen 0100 enthält lediglich einen Custom Container, in welchem dann später das \ac{ALV} angezeigt wird. Der Screen 0500 hat zum jetzigen Zeitpunkt nur ein Label und ein Eingabefeld, dessen Element sich in der Member Struktur des Screens der \ac{GUI} Klasse befindet. Das \ac{PBO} und das \ac{PAI} der Funktionsgruppe wurde dynamisch programmiert. Das bedeutet, dass je nach Screen die zugehörige Methode in der \ac{GUI} Klasse aufgerufen wird. Die User Befehle (OK Code) werden in ein Member Feld der \ac{GUI} Klasse geschrieben. Außerdem wurde für das Maintenance Programm ein extra Selektionsbildschirm angelegt, in welchem man gewisse Parameter wie Benutzer, Auftragsnummer usw. eingeben kann und somit die dargestellten Aufträge gefiltert werden können. Screenshots der Anwendung befinden sich unter \Anhang{Screenshots}.

Screenshots der Anwendung in der Entwicklungsphase mit Dummy-Daten befinden sich im \Anhang{Screenshots}.

\subsection{Implementierung PBO und PAI}
\label{sec:Implementierung PBO und PAI}
Jeder Screen der Funktionsgruppe hat seine eigene \ac{PBO} und \ac{PAI} Methode in der GUI Klasse. Im PBO werden die Daten geladen, bevor sie dann auf dem Screen angezeigt werden. Dies passiert, indem die jeweilige Controller Methode aufgerufen wird. Die Daten werden allerdings nicht jedes Mal neu geladen wenn das \ac{PBO} aufgerufen wird, sondern nur, wenn die ALV Struktur, welche in der Member Struktur des jeweiligen Screens ist, Initial also ``leer`` ist. Dadurch wird verhindert, dass zu viele Datenbankzugriffe erfolgen, da jedes Mal die Daten neu geladen werden. Nichtsdestotrotz kann eine Refresh einleiten werden, indem einfach die \ac{ALV} Struktur geleert wird. Im \ac{PAI} werden all User Befehle (OK-Code) abgefangen, welche vom Screen geworfen werden und dann die jeweilige Action ausgeführt. Den OK-Code des jeweiligen Buttons wird im Screen-Painter bzw. im Status des jeweiligen Screens definiert.

\subsection{Implementierung der Geschäftslogik ECC}
\label{sec:Implementierung der Geschäftslogik ECC}
Die eigentliche Geschäftslogik und die Datenbankzugriffe finden alle im Controller statt. Hier wurden mehrere Methoden implementiert, welche die gesamten Aufträge, die derzeit unterstützt werden, (Prozessaufträge, Produktionsaufträge aus der AUFK mit join auf die AFKO für Material Infos und Planaufträge aus der PLAF) laden. Außerdem wurde die Speicherlogik implementiert. In der Member Struktur des Screens gibt es zwei Tabellen, eine für die Daten, die dann tatsächlich im \ac{ALV} angezeigt werden und eine andere, in welcher immer die originalen Daten seit dem letzten Speichern enthalten sind. Beim Speichern werden nun diese zwei Tabellen verglichen und so alle Aufträge, welche sich nicht geändert haben, aussortiert, sodass die Speicherlogik nur auf die tatsächlich modifizierten oder erstellten Aufträge angewendet wird. Diese Aufträge werden dann mithilfe eines RFC ins \ac{APO} System transferiert. (siehe Kapitel~\ref{sec:Implementierung der Geschäftslogik APO}: \nameref{sec:Implementierung der Geschäftslogik APO})     

\subsection{Implementierung der COR Erweiterung}
\label{sec:Implementierung der COR Erweiterung}   
Um die COR Transaktion (1-3) zu erweitern, musste zunächst einmal ein passender Erweiterungspunkt gefunden werden, welcher zum einen, einen Screen Exit und zum anderen, zwei Functions Exits vor und nach dem Laden der Daten hat. Verwendet wurde das Enhancement PPCO0020. Diese bietet alle Komponenten, die zum Anzeigen der Daten benötigt wurden. Zuerst wurde das Screen Exit erstellt und mittels des Screen Painters ein simpler Screen mit einem Label und einem Eingabefeld erstellt und aktiviert. Dann wurde das \ac{PBO} Modul um eine Methode erweitert, sodass das Eingabefeld in der COR3 deaktiviert wird, da diese Transaktion nur zum Anzeigen ist. Außerdem wurde in dem Top Include eine globale Struktur vom Typ AUFK angelegt, dessen ZZ\_ORDER\_COMMENT Feld hinter dem Eingabe Feld liegt. In dem ersten Function Exit, wird diese Struktur dann gefüllt. Da der Planer aber auch die Möglichkeit haben soll, Kommentare von Prozessaufträgen zu ändern bzw. beim Anlegen eines Auftrags anzugeben, wurde noch ein weiterer Funktionsbaustein benötigt, da der oben genannte, keinen Function Exit für das Speichern hat, von wo aus unsere eigene Speicherlogik aufgerufen werden kann. Hierzu wurde der Erweiterungspunkt PPCO0007 gewählt. Dieser Erweiterungspunkt liefert einen Function Exit aus welchem dann eine statische Methode aus dem Controller aufgerufen wird, damit der geänderte Kommentar nicht nur in der AUFK sondern auch in der /CAMELOT/OC\_COMT gespeichert wird und von wo außerdem der \ac{RFC} ausgeführt wird, damit der Kommentar ins \ac{APO} transferiert wird. Näheres siehe Kapitel~\ref{sec:Implementierung der Geschäftslogik APO}: \nameref{sec:Implementierung der Geschäftslogik APO}.

\subsection{Implementierung der Datenstruktur APO}
\label{sec:Implementierung der Datenstruktur APO} 
Nachdem im \ac{ECC} System nun alles Implementiert worden war, musste nun ein Großteil der selben Datenstrukturen auch im \ac{APO} angelegt werden. Eine Liste aller Dictionary-Objekte kann dem Anhang entnommen werden. Des Weiteren wurde die /SAPAPO/ORDFLDS Datenbank Tabelle um ein Feld, ORDER\_COMMENT, erweitert. Im \ac{APO} wird keine extra Datenbank wie im \ac{ECC} benötigt, da für alle Aufträge die /SAPAPO/ORDFLDS Tabelle benutzt werden kann.

Screenshots der Anwendung in der Entwicklungsphase mit Dummy-Daten befinden sich im \Anhang{Screenshots}.

\subsection{Implementierung der Benutzeroberfläche APO}
\label{sec:Implementierung der Benutzeroberfläche APO} 
Ähnlich wie im \ac{ECC} musste ein Screen(0100) erstellt werden, auf welchem das \ac{ALV} mit den Auftragsdaten und dem Kommentar angezeigt wird. Der zweite Screen, der im \ac{ECC} angelegt wurde, wird im \ac{APO} nicht benötigt, da automatisch alle Kommentaren in der /SAPAPO/ORDFLDS im Feld ORDER\_COMMENT gespeichert werden. Der Screen 0100 ist genauso aufgebaut wie im \ac{ECC}, nur der Selektionsbildschirm fällt zum jetzigen Zeitpunkt deutlich kleiner aus, da man nur nach Auftragsnummern filtern kann.  

\subsection{Implementierung der Geschäftslogik APO}
\label{sec:Implementierung der Geschäftslogik APO}  
Wie im \ac{ECC} findet auch im \ac{APO} die gesamte Geschäftlogik im Controller statt. Neben den selben Klassen,die auch im \ac{ECC} vorhanden sind (Constants, Controller, \ac{GUI}, \ac{ALV}) gibt es eine extra Klasse mit dem Namen /CAMELOT/CL\_OC\_RRP, welche für den \ac{BAdI} und die implizite Erweiterung der RRP3 genutzt wird. Außerdem gibt es neben der Funktionsgruppe, welche für das Hauptprogramm genutzt wird, eine weitere Funktionsgruppe /CAMELOT/OC\_COMMENT mit dem Funktionsmodul /CAMELOT/OC\_COMMENT\_SYNC welche Remote-Enabled ist. Das bedeutet sie kann aus einem anderen System heraus aufgerufen werden. Diese Methode hat als Importparamter eine Tabelle mit dem Tabellentyp /CAMELOT/OC\_ORD\_COMMENT\_RFC\_T (siehe \Anhang{Dictionary-Objekte}). Diese Funktion dient zum Transport der Kommentare vom \ac{ECC} ins \ac{APO}. Die Struktur der Tabelle beinhaltet nur die Auftragsnummer und den Kommentar, um den Traffic möglichst gering zu halten. Die Methode selber sucht mithilfe eines SAP Funktionsbausteins /SAPAPO/DM\_ORDER-\_GET\_ORDID die richtige Auftrags-Id (Orderid) aus dem Livecache zu der gegebenen Auftragsnummer. Mithilfe der Auftrags-Id und dem Kommentar wird dann die /SAPAPO/ORDFLDS Tabelle geupdatet.  

\subsection{Implementierung der RRP3 Erweiterung}
\label{sec:Implementierung der RRP3 Erweiterung}   
Um die RRP3 zu erweitern wurde nicht wie bei der COR1-3 Customer-Exits sondern ein \ac{BAdI} und eine implizite Erweiterung verwendet. Der Unterschied zwischen einem Customer-Exits und einem \ac{BAdI} ist, dass der \ac{BAdI} die neuere objektorientierte Variante eines Customer-Exits ist. Statt in Funktionsmodule Code einzufügen wird eine vordefinierte Klasse implementiert, deren Methoden wie bei den alten Customer-Exits zu einem bestimmten Zeitpunkt aufgerufen werden. Für diese RRP3 Erweiterung wurden der \ac{BAdI} /SAPAPO/RRP\_IO\_COL benötigt. Mit diesem war es möglich, an den Feldkatalog, eine interne Tabelle mit Informationen über darzustellende Felder, der RRP3 das Feld Order\_Comment anzufügen damit dieses im \ac{ALV} erscheint. Mittels einer zweiten Methode konnten dann die entsprechenden Kommentare in die Tabelle geschrieben werden. Außerdem musste eine implizite Erweiterung angelegt werden, da es mithilfe von Customer-Exits oder \ac{BAdI}s nicht möglich war, die t-style Tabelle der einzelnen Elemente in der \ac{ALV} Tabelle zu ändern, was allerding absolut notwendig ist, um z.B. den Kommentar editierbar zu machen. Die jeweiligen Methoden des \ac{BAdI}s und der impliziten Erweiterung rufen eine statische Methode in der RRP3 Klasse auf, welche genau den selben Namen hat wie die eigentliche Methode des \ac{BAdI}s, um einen besseren Überblick zu verschaffen und sie später gut bei Kunden implementieren zu können. Diese Methoden holen sich dann die Instance des Controllers bzw. eine wird erstellt und rufen dann die jeweiligen Controller Methoden auf.

\Zwischenstand{Implementierungsphase}{Implementierung}
